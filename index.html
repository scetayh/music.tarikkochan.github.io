<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>music.tarikkochan.top</title>
  <style>
    /* 简单布局：不美化，优先功能 */
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; padding: 1rem; }
    #controls { display:flex; gap:0.5rem; align-items:center; margin-bottom: 1rem; }
    #playlistButtons { display:flex; gap:0.5rem; flex-wrap:wrap; margin-bottom:1rem; }
    button.playlist-btn { padding:0.4rem 0.6rem; cursor:pointer; }
    #main { display:flex; gap:1rem; align-items:flex-start; }
    #songList { min-width:280px; max-height:480px; overflow:auto; border:1px solid #ddd; padding:0.5rem; }
    #songList li { list-style:none; padding:0.4rem; cursor:pointer; border-bottom:1px solid #f4f4f4; }
    #songList li:hover { background:#f7f7f7; }
    #songList li .artist { color:#666; font-size:0.85rem; }
    #info { flex:1; border:1px solid #ddd; padding:0.5rem; max-height:480px; overflow:auto }
    #lyrics { white-space:pre-wrap; font-size:0.95rem; }
    .lyric-line { padding:0.2rem; border-radius:3px; }
    .lyric-line.current { background: #fffae6; }
    .bilingual .orig { font-weight:600 }
    .cover { width:120px; height:120px; object-fit:cover; border:1px solid #ddd; }
    #player { display:inline-block; }

    hidden {display: none; }
  </style>
</head>
<body>
  <h2>music.tarikkochan.top（基于NyxerPlayer）</h2>

  <p>
    在点按 <strong>播放 / 暂停</strong> 按钮后，请耐心等待 10 秒左右。
  </p>

  <div id="controls">
    <span style="position: absolute; left: -9999px;">
      <button id="showBtn"></button>
    </span>
    <button id="playBtn">播放 / 暂停</button>
    <div id="player" style="display:inline-block"></div>
  </div>

  <div id="playlistButtons" aria-label="歌单选择">少女祈祷中...</div>

  <div id="main">
    <ul id="songList" aria-label="歌曲列表">选择歌单</ul>

    <div id="info">
      <div style="display:flex;gap:1rem;margin-bottom:1rem;align-items:center">
        <img id="cover" class="cover" src="" alt="专辑封面" />
        <div>
          <div id="currentTitle" style="font-weight:600"></div>
          <div id="currentArtist" style="color:#666"></div>
        </div>
      </div>

      <!-- <h4>完整歌词（如有）</h4> -->
      <div id="lyrics">暂无歌词</div>
    </div>
  </div>

  <script type="module">
    import { initPlayer } from 'https://esm.sh/nyx-player'

    const METING_API = 'https://api.injahow.cn/meting/'

    // 解析 playlist url，和 package 中 PlayList.parserURL 的逻辑一致
    function parseAccessibleURL(url) {
      const rules = [
        [/music.163.com.*song.*id=(\d+)/, 'netease', 'song'],
        [/music.163.com.*album.*id=(\d+)/, 'netease', 'album'],
        [/music.163.com.*artist.*id=(\d+)/, 'netease', 'artist'],
        [/music.163.com.*playlist.*id=(\d+)/, 'netease', 'playlist'],
        [/music.163.com.*discover\/toplist.*id=(\d+)/, 'netease', 'playlist'],
        [/y.qq.com.*song\/(\w+)(.html)?/, 'tencent', 'song'],
        [/y.qq.com.*album\/(\w+)(.html)?/, 'tencent', 'album'],
        [/y.qq.com.*singer\/(\w+)(.html)?/, 'tencent', 'artist'],
        [/y.qq.com.*playsquare\/(\w+)(.html)?/, 'tencent', 'playlist'],
        [/y.qq.com.*playlist\/(\w+)(.html)?/, 'tencent', 'playlist']
      ]
      for (const [patt, provider, type] of rules) {
        const res = patt.exec(url)
        if (res && res[1]) {
          return { id: res[1], provider, type }
        }
      }
      throw new Error('Unsupported URL: ' + url)
    }

    async function fetchPlaylist(url) {
      const acc = parseAccessibleURL(url)
      const res = await fetch(`${METING_API}?type=${acc.type}&id=${acc.id}&server=${acc.provider}`)
      const json = await res.json()
      return json // array of songs according to METING API
    }

    // LRC 解析（借鉴 nyx-player 的实现）
    function parseLyricLineTime(line) {
      const timePattern = /\[(\d{2}):(\d{2})(?:\.(\d{2,3}))?\]/
      const match = timePattern.exec(line)
      if (!match) return null
      const min = parseInt(match[1], 10) * 60
      const sec = parseInt(match[2], 10)
      const msecStr = match[3]
      let msec = 0
      if (msecStr) {
        if (msecStr.length === 2) msec = parseInt(msecStr, 10) / 100
        else msec = parseInt(msecStr, 10) / 1000
      }
      return min + sec + msec
    }

    function parseLRCContent(content) {
      const lines = content.split('\n').filter(Boolean)
      const parsed = []
      for (const line of lines) {
        const t = parseLyricLineTime(line)
        if (t === null) continue
        const bracketEnd = line.indexOf(']')
        const text = bracketEnd !== -1 ? line.substring(bracketEnd + 1).trim() : line.trim()
        parsed.push({ start: t, text })
      }
      // build groups by start time to support bilingual (same timestamp multiple lines)
      const groups = []
      parsed.sort((a,b)=>a.start-b.start)
      for (let i=0;i<parsed.length;i++){
        const s = parsed[i].start
        const texts = [parsed[i].text]
        let j = i+1
        while (j<parsed.length && parsed[j].start === s) {
          texts.push(parsed[j].text); j++
        }
        const end = j < parsed.length ? parsed[j].start : Infinity
        groups.push({ start: s, end, texts })
        i = j-1
      }
      return groups
    }

    // UI elements
    const playlistButtonsEl = document.getElementById('playlistButtons')
    const songListEl = document.getElementById('songList')
    const lyricsEl = document.getElementById('lyrics')
    const coverEl = document.getElementById('cover')
    const currentTitleEl = document.getElementById('currentTitle')
    const currentArtistEl = document.getElementById('currentArtist')

    let playlists = []

    // 加载 JSON
    async function loadPlaylists() {
      const res = await fetch('/playlists.json')
      playlists = await res.json()
      playlistButtonsEl.innerHTML = ''
      playlists.forEach((pl, idx) => {
        const btn = document.createElement('button')
        btn.textContent = pl.name
        btn.className = 'playlist-btn'
        btn.addEventListener('click', () => switchToPlaylist(idx))
        playlistButtonsEl.appendChild(btn)
      })

      // 初始化 nyx-player，传入所有 URL（用于标签和内部切换）
      const urls = playlists.map(p => ({ url: p.url, name: p.name }))
      initPlayer('#player', '#showBtn', urls, '#playBtn')

      // 为了首次显示第一个歌单的歌曲（如果页面需要），模拟点击第一个
      if (playlists.length > 0) {
        await switchToPlaylist(0)
      }
    }

    // 通过模拟点击内部的 tab 切换歌单，并在页面外列出歌曲
    async function switchToPlaylist(index) {
      // try to click the inside tab in nyx-player
      const tabLi = document.querySelector(`.tabs .nav li[data-index="${index}"]`)
      if (tabLi) tabLi.click()

      // fetch playlist data and render list
      songListEl.innerHTML = '少女祈祷中...'
      try {
        const songs = await fetchPlaylist(playlists[index].url)
        // sort — 这里默认按返回顺序，如果需要按名称排序可提供交互
        renderSongList(songs, index)
      }
      catch (e) {
        songListEl.innerHTML = '加载歌单失败：' + e.message
      }
    }

    // render songs
    function renderSongList(songs, playlistIndex) {
      songListEl.innerHTML = ''
      songs.forEach((song, i) => {
        const li = document.createElement('li')
        li.dataset.index = i
        li.innerHTML = `<div class="song-name">${song.name}</div><div class="artist">${song.artist}</div>`
        li.addEventListener('click', () => {
          // 显示歌词与封面（优先更新 UI）
          showSongDetail(song)

          // 生成 stream URL（兼容多种字段名）并记录调试信息
          function buildStreamUrl(song) {
            if (!song) return null
            if (typeof song.url === 'string' && song.url) return song.url
            var id = song.id || song.songId || song.song_id || song.sid || song.trackId || song.mid || song.aid
            var server = song.server || song.source || song.provider || 'netease'
            if (id) return METING_API + '?type=url&id=' + encodeURIComponent(id) + '&server=' + encodeURIComponent(server)
            return null
          }

          var streamUrl = buildStreamUrl(song)
          console.info('[PLAY-DEBUG] click external song', { playlistIndex: playlistIndex, index: i, name: song.name, song })
          console.info('[PLAY-DEBUG] built streamUrl', streamUrl)

          // 强制设定 audio.src 并重试，直到 audio.src 与期望一致或达到上限
          var audioEl = document.querySelector('#MusicPlayerRoot audio') || document.querySelector('audio')
          if (audioEl && streamUrl) {
            try {
              // 尽早启用 preload 和跨域，以便浏览器可并行预取并利用 CDN 缓存
              audioEl.preload = 'auto'
              audioEl.crossOrigin = 'anonymous'
              audioEl.setAttribute && audioEl.setAttribute('preload', 'auto')
            } catch (e) {}

            // 在 head 中插入或更新 preload link，帮助浏览器提前建立连接
            try {
              var existingPre = document.getElementById('__preload_audio')
              if (existingPre) {
                existingPre.href = streamUrl
              } else {
                var lk = document.createElement('link')
                lk.id = '__preload_audio'
                lk.rel = 'preload'
                lk.as = 'audio'
                lk.href = streamUrl
                lk.crossOrigin = 'anonymous'
                document.head && document.head.appendChild(lk)
              }
            } catch (e) {}
            var setAttempts = 0
            var setMax = 10
            var setIntervalId = setInterval(function () {
              try {
                setAttempts++
                audioEl.pause && audioEl.pause()
                audioEl.src = streamUrl
                audioEl.load && audioEl.load()
                var p = audioEl.play && audioEl.play()
                if (p && typeof p.then === 'function') p.catch(function () {})
                // check if set
                if (audioEl.src && audioEl.src.indexOf(streamUrl) !== -1) {
                  console.info('[PLAY-DEBUG] audio.src set OK', audioEl.src)
                  clearInterval(setIntervalId)
                }
                if (setAttempts >= setMax) {
                  clearInterval(setIntervalId)
                  console.warn('[PLAY-DEBUG] failed to confirm audio.src after retries', audioEl.src)
                }
              } catch (err) {
                console.error('[PLAY-DEBUG] set audio error', err)
                clearInterval(setIntervalId)
              }
            }, 200)
          } else {
            console.warn('[PLAY-DEBUG] no audio element or no streamUrl', { audioEl: !!audioEl, streamUrl })
          }

          // 记录希望的播放目标，便于调试或后续同步逻辑使用（带时间戳）
          window.__desiredPlayback = { playlistIndex: playlistIndex, index: i, streamUrl: streamUrl, timestamp: Date.now() }

          // 激活内置 tab，随后反复尝试点击内部 li 并标记 active（以强同步 UI）
          var tabLi = document.querySelector('.tabs .nav li[data-index="' + playlistIndex + '"]')
          if (tabLi) tabLi.click()

          var attempts = 0
          var maxAttempts = 20
          function tryClickInternal() {
            attempts++
            // 更稳健地查找当前可见的内部 ol，而不是直接按索引访问 NodeList
            var ols = document.querySelectorAll('.playlist ol')
            var internalList = null
            for (var k = 0; k < ols.length; k++) {
              var o = ols[k]
              try {
                if (o.offsetParent !== null) { internalList = o; break }
                var style = window.getComputedStyle(o)
                if (style && style.display !== 'none' && style.visibility !== 'hidden') { internalList = o; break }
              } catch (e) {}
            }
            // 如果只有一个 ol，则优先使用它
            if (!internalList && ols.length === 1) internalList = ols[0]

            if (internalList) {
              var items = internalList.querySelectorAll('li')
              var internalLi = items && items.length > i ? items[i] : null
              if (internalLi) {
                try {
                  // 清理同级的 current/active 标记（尽量配合内置样式）
                  items && Array.prototype.forEach.call(items, function(x){ try{x.classList && x.classList.remove && x.classList.remove('active'); x.classList.remove && x.classList.remove('current')}catch(e){} })
                  internalLi.classList && internalLi.classList.add && internalLi.classList.add('active')
                } catch (e) {}
                try { internalLi.click && internalLi.click() } catch(e){}
                console.info('[PLAY-DEBUG] clicked internal li', { playlistIndex: playlistIndex, index: i })
                return
              }
            }
            if (attempts < maxAttempts) setTimeout(tryClickInternal, 200)
            else console.warn('[PLAY-DEBUG] failed to find internal li to click', { playlistIndex: playlistIndex, index: i })
          }
          tryClickInternal()
          // 立即与延迟多次强制同步右侧 UI，覆盖可能的异步回写，并启用 UI 强制器（延长窗口）
          try { syncUIFromSong(song) } catch (e) {}
          setTimeout(function(){ try { syncUIFromSong(song) } catch(e){} }, 700)
          setTimeout(function(){ try { syncUIFromSong(song) } catch(e){} }, 2000)
          try { startUIEnforcer(song, 8000) } catch(e){}
        })
        songListEl.appendChild(li)
      })
    }

    // show current song info, fetch lyric and show
    let currentLyricGroups = []
    function showSongDetail(song) {
      currentTitleEl.textContent = song.name || ''
      currentArtistEl.textContent = song.artist || ''
      // cover
      if (song.pic) coverEl.src = song.pic
      else coverEl.src = ''

      // lyric fetch & render
      const lrcUrl = typeof song.lrc === 'string' ? song.lrc : (song.lrc && song.lrc.lyric ? song.lrc.lyric : '')
      if (!lrcUrl) {
        lyricsEl.textContent = '暂无歌词'
        currentLyricGroups = []
        return
      }
      fetch(lrcUrl).then(r => r.text()).then(text => {
        currentLyricGroups = parseLRCContent(text)
        renderLyrics(currentLyricGroups)
      }).catch(err => {
        lyricsEl.textContent = '获取歌词失败'
        currentLyricGroups = []
      })
    }

    // 强制同步右侧 UI（标题/艺术家/封面），用于抵消内置播放器异步回写
    function syncUIFromSong(song) {
      try {
        if (!song) return
        if (song.name) currentTitleEl.textContent = song.name
        if (song.artist) currentArtistEl.textContent = song.artist
        // 尝试多种常见字段名获取封面
        var pic = song.pic || (song.al && song.al.picUrl) || song.picUrl || (song.album && song.album.picUrl) || ''
        if (pic) {
          // preload then swap to avoid flash
          try {
            var img = new Image()
            img.onload = function(){ try { coverEl.src = pic } catch(e){} }
            img.onerror = function(){ /* keep existing */ }
            img.src = pic
          } catch (e) {
            try { coverEl.src = pic } catch(e){}
          }
        } else {
          // 不主动清空已有封面，避免闪烁
        }
      } catch (e) {
        // ignore
      }
    }

    // 启动 UI 强制器：在短时间内定期重写右侧 UI，并监听内部 DOM 变更以立即恢复期望内容
    function startUIEnforcer(song, durationMs) {
      try {
        durationMs = durationMs || 6000
        // 清理已有的 enforcer
        if (window.__uiEnforcer) {
          try { window.__uiEnforcer.observer.disconnect() } catch (e) {}
          try { clearInterval(window.__uiEnforcer.intervalId) } catch (e) {}
          window.__uiEnforcer = null
        }

        // 定期强制同步
        var intervalId = setInterval(function(){ try { syncUIFromSong(song) } catch(e){} }, 200)

        // 监听内部播放器区域的变化，若发生变更则立即覆盖为期望内容
        var root = document.querySelector('#MusicPlayerRoot') || document.body
        var observer = new MutationObserver(function(muts){ try { syncUIFromSong(song) } catch(e){} })
        observer.observe(root, { childList: true, subtree: true, attributes: true, characterData: true })

        // 记录并在超时后清理
        var timeoutId = setTimeout(function(){
          try { observer.disconnect() } catch(e){}
          try { clearInterval(intervalId) } catch(e){}
          if (window.__uiEnforcer && window.__uiEnforcer.timeoutId === timeoutId) window.__uiEnforcer = null
        }, durationMs)

        window.__uiEnforcer = { observer: observer, intervalId: intervalId, timeoutId: timeoutId }
      } catch (e) {
        // swallow
      }
    }

    function renderLyrics(groups) {
      if (!groups || groups.length === 0) {
        lyricsEl.textContent = '暂无歌词'
        return
      }
      lyricsEl.innerHTML = ''
      groups.forEach((g, idx) => {
        const d = document.createElement('div')
        d.className = 'lyric-line'
        d.dataset.start = g.start
        d.dataset.end = g.end
        if (g.texts.length === 1) {
          d.textContent = g.texts[0]
        }
        else {
          // bilingual
          d.classList.add('bilingual')
          const orig = document.createElement('div')
          orig.className = 'orig'
          orig.textContent = g.texts[0]
          const trans = document.createElement('div')
          trans.className = 'translate'
          trans.textContent = g.texts.slice(1).join(' / ')
          d.appendChild(orig)
          d.appendChild(trans)
        }
        lyricsEl.appendChild(d)
      })
    }

    // sync highlighting with the player's audio element
    function setupAudioSync() {
      const audio = document.querySelector('#MusicPlayerRoot audio')
      if (!audio) return
      let lastIdx = -1
      audio.addEventListener('timeupdate', () => {
        const time = audio.currentTime
        // find current index
        let idx = -1
        for (let i = 0; i < currentLyricGroups.length; i++) {
          const g = currentLyricGroups[i]
          if (time >= g.start && time <= g.end) { idx = i; break }
        }
        if (idx !== lastIdx) {
          lastIdx = idx
          // remove previous
          const all = lyricsEl.querySelectorAll('.lyric-line')
          all.forEach(el => el.classList.remove('current'))
          if (idx !== -1) {
            const cur = all[idx]
            if (cur) {
              cur.classList.add('current')
              // scroll into view
              cur.scrollIntoView({ block: 'center', behavior: 'smooth' })
            }
          }
        }
      })
    }


    // 拦截全局的播放事件来更新详情视图（当内置播放器切歌时）
    // 监听 mutation 当 song 变化时更新 info
    function watchPlayerSongChange() {
      // 手动轮询当前 song info 顶层区域
      setInterval(() => {
        // 如果外部点击设置了期望播放（window.__desiredPlayback），在短时间内
        // 如果实际 audio.src 还未与期望 streamUrl 同步，则不要让内部播放器覆盖右侧信息，
        // 以避免封面/标题闪回旧值。
        var desired = window.__desiredPlayback
        var audio = document.querySelector('#MusicPlayerRoot audio') || document.querySelector('audio')
        // 如果 audio 已经切到期望流，则认为同步完成，清除期望标记
        if (desired && audio && audio.src && desired.streamUrl && audio.src.indexOf(desired.streamUrl) !== -1) {
          try { delete window.__desiredPlayback } catch (e) { window.__desiredPlayback = null }
          desired = null
        }

        // 如果仍有期望播放且在短时间内（5s）未同步，则跳过内部覆盖，但仍确保歌词同步
        if (desired && (Date.now() - (desired.timestamp || 0) < 5000)) {
          setupAudioSync()
          return
        }

        // 打开 AudioInfo 中的 title 与 artist DOM（正常情况下允许内部播放器更新 UI）
        const titleEl = document.querySelector('.preview h4')
        const artistEl = document.querySelector('.preview span')
        if (titleEl && artistEl) {
          const t = titleEl.textContent || ''
          const a = artistEl.textContent || ''
          currentTitleEl.textContent = t
          currentArtistEl.textContent = a
        }
        // cover — 仅在有 src 时更新
        const coverImg = document.querySelector('.cover img')
        if (coverImg && coverImg.getAttribute('src')) {
          coverEl.src = coverImg.getAttribute('src')
        }

        // setup audio sync whenever audio exists
        setupAudioSync()
      }, 800)
    }

    // 初始化
    loadPlaylists()
    watchPlayerSongChange()
  </script>
</body>
</html>